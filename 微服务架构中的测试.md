# 微服务架构中的测试

## 什么是微服务架构? 以电商系统为例

![inventory](https://github.com/SmartsYoung/notebook/blob/main/img/servicecomb/inventory.png)

### 可以理解成实现了进程隔离的“模块”. 函数 -> 类 -> module -> package ->微服务的不断演进。


微服务就是将一个完整的系统，使用服务集成而不是数据集成，按照业务功能，拆分成一个个独立的子系统，在微服务结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在 Web 容器中，它们之间通过 RPC 方式通信。

上述电商系统中，将服务按照业务功能划分成库存服务、购物服务、存储服务等，每个服务独立运行和部署，对外提供restful API接口，每个服务提供拥有自己的数据库。

### 进程隔离带来很多好处，独立部署，更好的可伸缩性，技术栈独立，运行平台独立。

服务间并不需要组合成组建去发布，而是每个服务都是独立的；而且降低了服务之间的耦合。微服务架构模式使得每个服务独立扩展，运行平台独立，可以在docker， Linux，Windows等多种平台运行。甚至于，你可以使用更适合于服务资源需求的硬件。

系统之间的耦合度也大大降低，可以独立开发、独立部署、独立测试，系统与系统之间的边界非常明确，排错也变得相当容易，开发效率大大提升。



### 进程隔离的模块最直接影响是：原来的模块间是进程内调用变成RPC。

云原生应用应该是无状态的。所有的状态信息都应该从应用中抽离出来，并保存在支撑服务中，比如数据库中。正因为应用是无状态的，才可以由云平台快速的启动和停止，并进行垂直或水平扩展。

这个变化带来的挑战有：性能，可观测性，协作更复杂，事务性难以保证等。



### 每个微服务都有自己独立的数据库

针对服务自身的特点部署数据库，每种服务都有自己的数据库，另外，每种服务可以用更适合自己的数据库类型，比如，用户账号信息，必须使用支持关联型信息查询的数据库。

## 单个微服务的六边形模型

六边形架构也叫做端口适配器模式，将系统分为内部和外部两层六边形。内部专注于核心业务逻辑（domain），核心业务逻辑相对稳定，且需要被详尽测试。 外部六边形代表外部应用、外部请求和驱动等。内部和外部交互通过适配器工作。

- REST API:  post/orders:  参数：user_id, product_id, number
- Order Service 业务逻辑：检查库存是否足够；读取产品价格和优惠信息；计算订单金额；订单保存数据库做持久化。
- Order命令处理程序： e.g：处理增加/减少库存的消息，修改价格的消息
- 领域事件发布适配器： e.g: 订单保存成功后，生成支付消息，由支付微服务的命令处理程序处理。
- 记忆方法：3个大类：入站适配器，出站适配器，业务逻辑。2类适配器，通常各有2种接口。



![hexagon](https://github.com/SmartsYoung/notebook/blob/main/img/servicecomb/hexagon.png)

## 微服务是用户应用上云、全面解耦的基石

![componentizationToService](https://github.com/SmartsYoung/notebook/blob/main/img/servicecomb/componentizationToService.png)
传统IT应用开发过程中遇到的典型问题，比如非组件化的应用资源分散、数据不通问题；互联网+转型的传统企业遇到业务上新周期长、流量不确定等问题，还有集团性大企业在数字化转型过程中遇到个性化需求激增、多厂商难集成难管控等问题。

随着云原生技术的发展，以虚拟机为资源服务的资源云化开始向以应用为中心提供能力服务的应用云化演进。微服务凭借其独立、轻量级、去中心化、松耦合等特征，结合云上完善的自动化运维体系，帮助用户构筑快速试错、短平快交付、按需弹性的能力，解决用户关心的痛点问题。因此，微服务也成为云化时代的流行架构，可以说，微服务是用户应用上云、全面解耦的基石。

然而，微服务不是银弹，它面临着如何高效开发和上线、保障高可靠、问题快速定位与恢复、遗留系统低成本迁移等挑战。



## 微服务架构的优势    简单&强大

一个既“简单”的又“强大” 的后端架构模式。

### 简单：
- 每个服务相对较小并比较容易开发维护。
- 服务可以独立的部署。
- 每个微服务更适合小团队开发管理，团队内聚性更高
- 更容易实验和采纳新的技术。
- 更容易进行测试。
这部分内容学习成本低， demo也可以作为生产系统的一部分

### 强大

- 使大型的复杂应用程序可以持续的部署和持续的交付。
- 更容易对已有大型系统进行修改和扩展
- 容易进行的性能优化
- 更高的可用性
- 更容易的进行性能伸缩性

## 要从微服务架构中受益，必须实现“自动”测试

- “自动”测试是指测试要可靠和高效。
- 持续的部署和持续的交付，可靠和高效的测试是基础。
- 单个微服务简单化的代价：在组件级别的依赖变得更多更复杂，因此该微服务能正常的执行自身功能，并且正确的执行和其他微服务的“契约”非常重要。
- 对性能进行优化的的部分，往往需要更多测试。包括功能性测试和性能测试。


## 微服务架构中测试“相对”更容易



![servicing](https://github.com/SmartsYoung/notebook/blob/main/img/servicecomb/servicing.png)

- 每个微服务功能更单一，更简单。更有利于测试。
- 每个微服务对其他微服务的依赖变多，变复杂。不利于测试。
- 每个微服务对其他微服务的依赖方式/调用方式更统一。有利于测试。
- 独立部署，有利于组件级验收测试。
- 总体：利大于弊。

## 优化测试是优化测试性价比的游戏，用最少的成本，获得最多的测试收益。

![testPyramid](https://github.com/SmartsYoung/notebook/blob/main/img/servicecomb/testPyramid.png)

从上图中可以看出，要把软件测试按照不同粒度来分组：

（1）**多做单元测试和集成测试**，单元测试的范围相对较窄，覆盖面较少，但单元测试执行速度较快，能及时发现问题，多个单元测试能覆盖较多的测试组合。

（2）**少做服务级功能测试、端到端测试**，端到端的测试执行速度慢，出现问题时定位困难，每次执行需要较长的等待时间。

## 利用工具和最佳实践，进一步减少每一级的成本

**单元测试**：验证简单的业务逻辑。语言相关，如junit。写代码的基本功。
**集成测试**：同时验证业务逻辑和它的依赖方，比如持久化。微服务语境下，因为单个微服务足够简单，同时**单个微服务的验收测试（组件测试）**也更为重要，且统一，在我们的实践中，更多的考虑是下一级：单个微服务的组件测试。

### 单个微服务的组件测试：从入站和出站2个方向对微服务做验收测试

### 单个微服务的组件测试-消费者驱动的契约测试

消费者驱动的契约（Consumer Driven Contract）是一种 API 开发的实践，把行为驱动开发的思想应用到了 API 的设计中，消费者驱动的含义是由 API 的消费者来驱动 API 的设计。如果 API 的目的是满足消费者的需求，那么 API 的消费者对于 API 有决定权，包括 API 中包含的全部路径，以及每个路径的请求和响应的内容格式。API 的提供者需要按照消费者指定的契约，来完成 API 的具体实现。

**测试契约**：

```shell
request: {
    type:request-http-rest,
    properties:{
        method: 'POST',
        url: '/orders'
    }
},
response: {
    type:respose-http-rest,
    properties:{
        status: 200,
        headers: ['Content-Type:application/json']
        body: {
        type: 'json',
        content: '...'
    }
        method: 'POST',
        url: '/orders'
    }
},
sideEffercts {
    type: mq-message,
    properties: {
        queueId: xxx,
        content: '...'
    }
}
```



对于微服务A 依赖 微服务B:

- 由微服务A驱动
- 既然是契约，需要一个流程让开发微服务A和微服务B的2个团队达成一致，并确认。我们的通常的流程为A提交契约，通过PR的形式提交给B，B合入PR则表示审核同意。
- 该契约能生成微服务B的验收测试的代码。团队B会维护多份契约，每份契约代表不同的其他微服务对其验收测试的要求。团队B需要保证它每次对微服务B的修改，不会破坏任何一份契约或取得某消费方的认可。
- 该契约同时能生成微服务A调用微服务B时的mock（stub)。让服务的A的验收测试可以执行。

### 端到端测试

- 在微服务的环境下，因为强调高频率的发布，端到端测试比较困难。至少需要维护一个staging环境。
- 集成测试的脆弱性：找一条相对简单和稳定的路径（极不稳定不如手工测试），能测试尽量多的微服务。能对部署环境的正确性做一些验证。
- 换个思路：我们的目标是用预算内尽量少的成本，在对用户不利影响尽量小的情况下，尽量多的发现系统问题。金丝雀发布+可观测的微服务模式在特定的场景下也能达到该目标。可实现某些场景下替代端到端测试。

### 可观测的微服务模式-分布式跟踪

- 可观测性的基础是分布式追踪。在对每一个外部请求生成一个UID,后续的所有请求以及事件带上同样的UID.

- 日志聚合，将记录每个微服务活动的日志写入集中式日志记录服务器。服务器提供索引和报警功能。常用：ELK.
- 分布式跟踪。日志聚合的3大问题：1.慢，2.上报缺乏优先级，3.对跟踪的配置缺乏统一的管理。分布式跟踪希望解决上面问题，但也有代价。原理是每个微服务中增加探针配合分布式跟踪服务器完成（如Open Zipkin)



## Apache ServiceComb 融合开源生态的一站式微服务解决方案

![hwApache](https://github.com/SmartsYoung/notebook/blob/main/img/servicecomb/hwApache.png)

## 首个Apache微服务顶级项目
提供一站式的微服务开源解决方案，致力于帮助企业、用户和开发者将应用轻松微服务化上云，实现对微服务应用的高效运维管理

- 2018 OSCAR尖峰开源技术创新奖
- 2018 COSCL首届中国优秀开源项目一等奖
- 2019 首个行业微服务标准的核心参考框架

## 社区召集令

#### 对用户们，我们想说

**选择Apache ServiceComb，我们会认真对待您在微信群/Github Issue/MailGroup的：**
<font color=#FF0000 >**每一个问题**</font>
<font color=#FF0000 >**每一个建议**</font>
**期待与您共建社区，持之以恒，共同解决微服务难题**
<font color=#FF0000 >**保护您的选择是我们的使命**</font>

#### 对开发者们，我们想说

**不论您是**
<font color=#FF0000 >**大咖/已是微服务开发者 / 即将进入微服务开发者 / 单纯寻求开源贡献的开发者 / 学校学者 / 学生 /……**</font>
**我们期待您的加盟与贡献**

**如果您准备贡献代码，请扫描二维码进群，**<font color=#FF0000 >**备注“贡献代码”**</font>
**我们将会与您进行**<font color=#FF0000 >**一对一交流协作**</font>

**PS: <font color=#FF0000 >不需要任何的顾虑，</font>我们来一起做点有意思的事情**
<font color=#FF0000 >**未来它会是XX云上服务，会是XX企业方案，运行在各样的业务中**</font>

### 加入我们
欢迎添加ServiceComb小助手，加入微服务技术交流群，架构、设计、开发、解BUG、调优，总有你感兴趣的话题。

欢迎关注微服务蜂巢公众号，获取更多微服务技术干货、咨询文章

<center class="half">
    <img src="https://github.com/SmartsYoung/notebook/blob/main/img/servicecomb/servicecombHelper.png"/><img src="https://github.com/SmartsYoung/notebook/blob/main/img/servicecomb/wechatPublic.png"/></center>



[社区网站](https://servicecomb.apache.org)  http://servicecomb.apache.org

[Github](https://github.com/apache?q=servicecomb) https://github.com/apache?q=servicecomb